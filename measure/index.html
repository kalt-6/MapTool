<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- FIXED: Added interactive-widget=resizes-content to tell iOS to resize the viewport instead of scrolling the page -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
    <meta name="description" content="Calculate the distance between two points on a global map.">
    <title>Distance Calculator</title>
    
    <link rel="icon" type="image/png" href="logo.png">

    <!-- Performance Preconnects -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://basemaps.cartocdn.com">
    <link rel="preconnect" href="https://nominatim.openstreetmap.org">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
     
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        /* FIXED: Apply position: fixed to body/html. This is crucial for iOS. 
           It stops the "scroll into view" behavior that pushes the page under the notch. */
        html, body { 
            font-family: 'Inter', sans-serif; 
            margin: 0; 
            padding: 0; 
            width: 100%;
            height: 100%;
            overflow: hidden; 
            position: fixed; 
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        #map { 
            height: 100%; 
            width: 100%; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            background-color: #111; 
        }
        
        /* UI Components */
        .glass-panel {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.8), 0 2px 4px -1px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
        }
        
        /* Leaflet Overrides */
        .leaflet-bar a { background-color: #0a0a0a !important; color: #e5e5e5 !important; border-bottom: 1px solid #262626 !important; }
        .leaflet-bar a:hover { background-color: #262626 !important; }
        .leaflet-container .leaflet-control-attribution {
            background: rgba(0, 0, 0, 0.6) !important; color: #666 !important; font-size: 11px; border-radius: 4px 0 0 0;
        }
        .leaflet-container .leaflet-control-attribution a { color: #888 !important; text-decoration: none; }
        .leaflet-container .leaflet-control-attribution a:hover { color: #ccc !important; text-decoration: underline; }
        
        /* Loaders */
        .loader {
            border: 2px solid #e5e5e5; border-top: 2px solid #3b82f6; border-radius: 50%;
            width: 12px; height: 12px; animation: spin 1s linear infinite;
        }
        .loader-red { border-top-color: #ef4444; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Mobile optimization for collapsed state */
        .rotate-180 { transform: rotate(180deg); }

        /* Hide zoom controls on mobile devices */
        @media (max-width: 768px) {
            .leaflet-control-zoom { display: none !important; }
        }

        /* Custom positioning class for the main panel */
        .panel-position {
            position: absolute;
            left: 1rem; 
            width: calc(100% - 2rem);
            max-width: 24rem; 
            z-index: 1000;
            pointer-events: none;
            transition: all 0.3s ease;
            
            /* Mobile Default: Bottom with Safe Area support */
            /* This puts it exactly 0.5rem above the home swipe indicator */
            bottom: calc(0.5rem + env(safe-area-inset-bottom));
            top: auto;
        }

        /* Desktop Override */
        @media (min-width: 1024px) {
            .panel-position {
                top: 1rem;
                bottom: auto;
                width: 24rem; 
            }
        }
    </style>
</head>
<body class="bg-black">

    <div id="map"></div>

    <!-- Responsive Container using custom .panel-position class -->
    <div class="panel-position">
        <div class="glass-panel rounded-xl p-3 md:p-4 pointer-events-auto shadow-2xl overflow-hidden">
            
            <!-- Header Row -->
            <div class="flex items-center justify-between mb-0">
                <div class="flex items-center gap-2 overflow-hidden">
                    <div class="p-1.5 bg-neutral-800 rounded-lg shrink-0">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>
                    </div>
                    <!-- Title -->
                    <div class="flex flex-col">
                        <h1 class="text-sm md:text-base font-bold text-white truncate leading-tight">Distance Calculator</h1>
                        <span id="headerDistance" class="text-xs md:text-sm font-bold text-blue-400 font-mono hidden">0 mi</span>
                    </div>
                </div>
                
                <div class="flex items-center gap-2">
                    <button onclick="resetMap()" aria-label="Reset Map" class="text-[10px] font-bold text-neutral-400 border border-neutral-600 hover:border-red-500 hover:text-red-500 hover:bg-red-900/20 px-2 py-1 rounded transition-all">
                        Reset
                    </button>
                    <!-- Toggle Button -->
                    <button onclick="togglePanel()" id="toggleBtn" aria-label="Toggle Panel" class="p-1 text-neutral-400 hover:text-white hover:bg-neutral-700/50 rounded transition-all">
                        <svg id="chevronIcon" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
                    </button>
                </div>
            </div>

            <!-- Collapsible Content -->
            <div id="panelContent" class="transition-all duration-300 ease-in-out max-h-[60vh] md:max-h-[500px] overflow-y-auto opacity-100 mt-3 md:mt-4">
                
                <!-- Input 1 (Blue) -->
                <div class="mb-3 relative group">
                    <div class="absolute left-3.5 top-1/2 -translate-y-1/2 w-2 h-2 rounded-full bg-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.6)]"></div>
                    <input type="text" id="input1" aria-label="Location A" placeholder="Point A (e.g., New York)" class="w-full pl-8 pr-16 py-2 bg-neutral-900/50 border border-neutral-700 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 transition-all text-base text-white placeholder-neutral-500 focus:bg-neutral-900">
                    <button id="btn1" aria-label="Find Location A" class="absolute right-1.5 top-1.5 bg-white hover:bg-neutral-200 text-black text-[10px] font-bold px-2 py-1.5 rounded transition-colors shadow-lg shadow-black/20">
                        Find
                    </button>
                </div>

                <!-- Input 2 (Red) -->
                <div class="mb-4 relative group">
                    <div class="absolute left-3.5 top-1/2 -translate-y-1/2 w-2 h-2 rounded-full bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]"></div>
                    <input type="text" id="input2" aria-label="Location B" placeholder="Point B (e.g., London)" class="w-full pl-8 pr-16 py-2 bg-neutral-900/50 border border-neutral-700 rounded-lg focus:outline-none focus:ring-1 focus:ring-red-500 focus:border-red-500 transition-all text-base text-white placeholder-neutral-500 focus:bg-neutral-900">
                    <button id="btn2" aria-label="Find Location B" class="absolute right-1.5 top-1.5 bg-white hover:bg-neutral-200 text-black text-[10px] font-bold px-2 py-1.5 rounded transition-colors shadow-lg shadow-black/20">
                        Find
                    </button>
                </div>

                <!-- Results Info -->
                <div id="resultPanel" class="pt-3 md:pt-4 border-t border-white/10" aria-live="polite">
                    <div class="flex justify-between items-center">
                        <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wide">Distance</h2>
                        <div class="flex items-center gap-2 text-sm font-bold text-white bg-neutral-800 border border-neutral-700 px-3 py-1.5 rounded-lg select-none font-mono">
                            <span id="distanceText">0 miles</span>
                        </div>
                    </div>
                </div>
                
                <!-- Error Toast -->
                <div id="errorMessage" role="alert" class="hidden mt-3 text-xs text-red-400 bg-red-950/30 p-2 rounded border border-red-900/50 flex items-center gap-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="errorText">Location not found.</span>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        const CONFIG = {
            ZOOM: 2,
            TILE: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
            R_MI: 3958.8, R_KM: 6371,
            TO_RAD: Math.PI / 180, TO_DEG: 180 / Math.PI
        };

        let map, allPolylines;
        let markers1 = [], markers2 = [];
        const els = {};
        let errorTimeout;
        let isPanelOpen = true;

        document.addEventListener('DOMContentLoaded', () => {
            ['input1', 'btn1', 'input2', 'btn2', 'distanceText', 'errorMessage', 'errorText', 'panelContent', 'chevronIcon', 'headerDistance'].forEach(id => els[id] = document.getElementById(id));
            initMap();
            setupEvents();
            updateIconState();
            window.addEventListener('resize', updateIconState);
            
            // FIXED: Additional safety - ensure we are at top if viewport shifts
            window.addEventListener('resize', () => {
                if (window.scrollY > 0) window.scrollTo(0, 0);
            });
        });

        function initMap() {
            map = L.map('map', {
                worldCopyJump: true, 
                minZoom: 2, 
                zoomControl: false,
                maxBounds: [[-85, -Infinity], [85, Infinity]], 
                maxBoundsViscosity: 1.0
            }).setView([20, 0], CONFIG.ZOOM);

            L.tileLayer(CONFIG.TILE, {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                subdomains: 'abcd', maxZoom: 20
            }).addTo(map);

            L.control.zoom({ position: 'bottomright' }).addTo(map);
            allPolylines = L.layerGroup().addTo(map);
        }
        
        function togglePanel() {
            isPanelOpen = !isPanelOpen;
            
            if (isPanelOpen) {
                // Open
                els.panelContent.style.maxHeight = window.innerWidth < 1024 ? '60vh' : '500px';
                els.panelContent.style.opacity = '1';
                els.panelContent.style.marginTop = window.innerWidth < 1024 ? '0.75rem' : '1rem'; 
                els.panelContent.style.marginBottom = '0';
                els.headerDistance.classList.add('hidden'); 
            } else {
                // Close
                els.panelContent.style.maxHeight = '0';
                els.panelContent.style.opacity = '0';
                els.panelContent.style.marginTop = '0';
                els.panelContent.style.marginBottom = '0';
                
                if (els.distanceText.textContent !== "0 miles") {
                    els.headerDistance.textContent = els.distanceText.textContent;
                    els.headerDistance.classList.remove('hidden');
                }
            }
            updateIconState();
        }

        function updateIconState() {
            const isMobile = window.innerWidth < 1024;
            
            if (isPanelOpen) {
                if (isMobile) els.chevronIcon.classList.add('rotate-180');
                else els.chevronIcon.classList.remove('rotate-180');
            } else {
                if (isMobile) els.chevronIcon.classList.remove('rotate-180');
                else els.chevronIcon.classList.add('rotate-180');
            }
        }

        function createIcon(color) {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="36" height="36" fill="${color}" stroke="white" stroke-width="1.5" style="filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>`;
            return L.divIcon({ html: svg, className: '', iconSize: [36, 36], iconAnchor: [18, 36] });
        }

        function createMarkers(latlng, color, arr) {
            arr.forEach(m => map.removeLayer(m));
            arr.length = 0; 
            const icon = createIcon(color);
            for (let i = -3; i <= 3; i++) {
                const m = L.marker([latlng[0], latlng[1] + (i * 360)], { draggable: true, icon }).addTo(map);
                m.on('drag', (e) => onDrag(e, arr));
                arr.push(m);
            }
        }

        function onDrag(e, family) {
            const { lat, lng } = e.target.getLatLng();
            const clampedLat = Math.max(-85, Math.min(85, lat));
            let baseLng = lng;
            while (baseLng > 180) baseLng -= 360;
            while (baseLng < -180) baseLng += 360;

            family.forEach((m, i) => m.setLatLng([clampedLat, baseLng + ((i - 3) * 360)]));
            refresh();
        }

        function getPath(l1, l2) {
            const points = [];
            let lon2 = l2.lng;
            const diff = l2.lng - l1.lng;
            if (diff > 180) lon2 -= 360;
            else if (diff < -180) lon2 += 360;

            const lat1 = l1.lat * CONFIG.TO_RAD, lon1 = l1.lng * CONFIG.TO_RAD;
            const lat2 = l2.lat * CONFIG.TO_RAD, lon2R = lon2 * CONFIG.TO_RAD;
            const d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2R - lon1));

            if (Math.abs(d) < 1e-6) return [l1, l2];

            let lastLon = null;
            for (let i = 0; i <= 100; i++) {
                const f = i / 100, A = Math.sin((1 - f) * d) / Math.sin(d), B = Math.sin(f * d) / Math.sin(d);
                const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2R);
                const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2R);
                const z = A * Math.sin(lat1) + B * Math.sin(lat2);
                
                let lon = Math.atan2(y, x) * CONFIG.TO_DEG;
                if (lastLon !== null) {
                    if (lon - lastLon > 180) lon -= 360;
                    else if (lastLon - lon > 180) lon += 360;
                }
                
                let lat = Math.atan2(z, Math.sqrt(x*x + y*y)) * CONFIG.TO_DEG;
                lat = Math.max(-85, Math.min(85, lat));
                points.push(L.latLng(lat, lon));
                lastLon = lon;
            }
            return points;
        }

        function refresh() {
            allPolylines.clearLayers();
            if (markers1.length === 0 || markers2.length === 0) {
                els.distanceText.textContent = "0 miles";
                if (!isPanelOpen) els.headerDistance.classList.add('hidden');
                return;
            }

            const p1 = markers1[0].getLatLng(), p2 = markers2[0].getLatLng();
            const main = getPath(p1, p2);
            const opts = { color: '#FFFFFF', weight: 3, opacity: 0.7, dashArray: '5, 10' };

            for (let i = -3; i <= 3; i++) {
                L.polyline(main.map(p => L.latLng(p.lat, p.lng + (i * 360))), opts).addTo(allPolylines);
            }

            const dLat = (p2.lat - p1.lat) * CONFIG.TO_RAD, dLon = (p2.lng - p1.lng) * CONFIG.TO_RAD;
            const a = Math.sin(dLat/2)**2 + Math.sin(dLon/2)**2 * Math.cos(p1.lat * CONFIG.TO_RAD) * Math.cos(p2.lat * CONFIG.TO_RAD);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            const distStr = `${Math.round(CONFIG.R_MI * c).toLocaleString('en-US')} mi (${Math.round(CONFIG.R_KM * c).toLocaleString('en-US')} km)`;
            els.distanceText.textContent = distStr;
            
            if (!isPanelOpen) {
                els.headerDistance.textContent = distStr;
                els.headerDistance.classList.remove('hidden');
            }
        }

        function setupEvents() {
            const bind = (inp, btn, fam, color) => {
                btn.addEventListener('click', () => search(inp, btn, fam, color));
                inp.addEventListener('keydown', (e) => e.key === 'Enter' && search(inp, btn, fam, color));
            };
            bind(els.input1, els.btn1, markers1, '#3B82F6');
            bind(els.input2, els.btn2, markers2, '#EF4444');
        }

        async function search(inp, btn, family, color) {
            const q = inp.value.trim();
            if (!q) return;

            const txt = btn.innerText;
            btn.innerHTML = `<div class="loader ${btn.id === 'btn2' ? 'loader-red' : ''}"></div>`;
            btn.disabled = true;
            els.errorMessage.classList.add('hidden');

            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=1`);
                const data = await res.json();

                if (data?.[0]) {
                    const { lat, lon, display_name } = data[0];
                    const nLat = parseFloat(lat), nLon = parseFloat(lon);
                    
                    if (family.length === 0) {
                        createMarkers([nLat, nLon], color, family);
                    } else {
                        family.forEach((m, i) => m.setLatLng([nLat, nLon + ((i - 3) * 360)]));
                    }

                    inp.value = display_name.split(',')[0];
                    refresh();
                    
                    // FIXED: More conservative padding calculation
                    // Cap the padding to 35% of the viewport height to prevent the map from zooming out too much
                    // or pushing the pin off the top of the screen on small devices.
                    const isMobile = window.innerWidth < 1024;
                    const panel = document.querySelector('.glass-panel');
                    const maxPadding = window.innerHeight * 0.35; 
                    const panelHeight = panel ? panel.offsetHeight : 0;
                    const bottomPadding = isMobile ? Math.min(panelHeight, maxPadding) : 50;
                    
                    const fitOptions = {
                        paddingTopLeft: [20, 20], // Reduced from 50 to 20 for more space
                        paddingBottomRight: [20, bottomPadding],
                        animate: true,
                        duration: 1.5,
                        maxZoom: 10 // Increased maxZoom to ensure single points are visible clearly
                    };

                    if (markers1.length > 0 && markers2.length > 0) {
                        const bounds = L.latLngBounds(getPath(markers1[0].getLatLng(), markers2[0].getLatLng()));
                        if (bounds.isValid()) {
                            map.fitBounds(bounds, { ...fitOptions, maxZoom: 6 });
                        }
                    } else {
                        // For single point, use the increased maxZoom (10)
                        const b = L.latLngBounds([nLat, nLon], [nLat, nLon]);
                        map.fitBounds(b, fitOptions);
                    }

                } else {
                    showError('Location not found.');
                }
            } catch (e) { showError('Search failed.'); } 
            finally { btn.innerText = txt; btn.disabled = false; }
        }

        function showError(msg) {
            if (errorTimeout) clearTimeout(errorTimeout);
            els.errorText.textContent = msg;
            els.errorMessage.classList.remove('hidden');
            errorTimeout = setTimeout(() => els.errorMessage.classList.add('hidden'), 3000);
        }

        function resetMap() {
            if (errorTimeout) clearTimeout(errorTimeout);
            els.errorMessage.classList.add('hidden');

            els.input1.value = els.input2.value = '';
            [...markers1, ...markers2].forEach(m => map.removeLayer(m));
            markers1.length = 0;
            markers2.length = 0;
            
            refresh();
            map.setView([20, 0], CONFIG.ZOOM);
            if (!isPanelOpen) togglePanel();
        }
    </script>
</body>
</html>
