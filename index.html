<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Route Map</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
     
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <style>
        html, body, #map {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a; /* Dark background for the whole page */
        }
        /* Style for the search control container */
        .leaflet-top.leaflet-left .leaflet-control {
            margin-top: 10px;
            margin-left: 10px;
        }
        #search-container {
            background: #2d2d2d; /* Dark background for controls */
            color: #f0f0f0; /* Light text for controls */
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column; 
            gap: 8px;
        }
        .search-group {
            display: flex;
            align-items: center;
        }
        .search-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        .search-input {
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #f0f0f0;
            border-radius: 3px;
            padding: 5px;
            padding-right: 25px; 
            font-size: 14px;
            margin-right: 5px;
        }
        .search-input::placeholder {
            color: #aaa;
        }
        .clear-search {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-size: 20px;
            color: #ccc;
            display: none;
        }
        .search-button {
            padding: 5px 10px;
            border-radius: 3px;
            border: 1px solid #555;
            background: #3c3c3c;
            color: #f0f0f0;
            cursor: pointer;
        }
        .search-button:hover {
            background: #4d4d4d;
        }
        #distance-display {
            text-align: center; 
            padding-top: 8px; 
            font-weight: bold;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: #f0f0f0;
            border-top: 1px solid #444;
            margin-top: 4px;
        }
        /* Dark mode styles for Leaflet's default controls */
        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out {
            background-color: #2d2d2d !important;
            color: #f0f0f0 !important;
            border-color: #555 !important;
        }
        .leaflet-control-zoom-in:hover,
        .leaflet-control-zoom-out:hover {
            background-color: #3c3c3c !important;
        }
        .leaflet-bar a {
            background-color: #2d2d2d !important;
            color: #f0f0f0 !important;
            border-color: #555 !important;
        }
        .leaflet-bar a:hover {
            background-color: #3c3c3c !important;
        }
        .leaflet-control-attribution {
            background: rgba(45, 45, 45, 0.8) !important;
            color: #bbb !important;
        }
        .leaflet-control-attribution a {
            color: #8cb4ff !important;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <script>
        // --- Map Initialization ---
        const map = L.map('map', {
            worldCopyJump: true,
            minZoom: 1.4,
        }).setView([20, 0], 2);

        // Use the dark mode tile layer by default
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
	        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
	        subdomains: 'abcd',
	        maxZoom: 20,
            bounds: L.latLngBounds(L.latLng(-90, -180), L.latLng(90, 180))
        }).addTo(map);

        // --- Stable Panning Constraint ---
        map.on('moveend', function() {
            const padding = 100; // The visual buffer in pixels.
            const worldPixelBounds = map.getPixelWorldBounds();
            const viewPixelBounds = map.getPixelBounds();
            const mapSize = map.getSize();

            const viewTop = viewPixelBounds.min.y;
            const viewBottom = viewPixelBounds.max.y;

            const worldTop = worldPixelBounds.min.y;
            const worldBottom = worldPixelBounds.max.y;

            const currentCenterPx = map.project(map.getCenter());
            let newCenterPx = L.point(currentCenterPx.x, currentCenterPx.y);
            
            let needsCorrection = false;

            if (viewTop < worldTop - padding) {
                newCenterPx.y = worldTop - padding + (mapSize.y / 2);
                needsCorrection = true;
            }
            else if (viewBottom > worldBottom + padding) {
                newCenterPx.y = worldBottom + padding - (mapSize.y / 2);
                needsCorrection = true;
            }

            if (needsCorrection) {
                map.panTo(map.unproject(newCenterPx), { animate: true, duration: 0.2 });
            }
        });


        const allPolylines = L.layerGroup().addTo(map);

        // --- Marker Setup ---
        const initialPos1 = [40.71, -74.00]; // NYC
        const initialPos2 = [34.05, -118.24]; // Los Angeles

        const markerFamily1 = createMarkerFamily(initialPos1, '#3B82F6');
        const markerFamily2 = createMarkerFamily(initialPos2, '#EF4444');

        function createMarkerFamily(latlng, color) {
            const family = [];
            const createMarker = (pos) => L.marker(pos, { 
                draggable: true, 
                icon: createCustomIcon(color, 1), 
                color: color 
            }).addTo(map);

            for (let i = -3; i <= 3; i++) {
                const offset = i * 360;
                family.push(createMarker([latlng[0], latlng[1] + offset]));
            }
            return family;
        }

        // --- Core Logic & Helper Functions ---

        function getGreatCirclePoints(latlng1, latlng2) {
            const points = [];
            const numPoints = 100;
            let lon2_for_path = latlng2.lng;
            const diff = latlng2.lng - latlng1.lng;
            if (diff > 180) lon2_for_path -= 360;
            else if (diff < -180) lon2_for_path += 360;
            const lat1 = latlng1.lat * Math.PI / 180, lon1 = latlng1.lng * Math.PI / 180;
            const lat2 = latlng2.lat * Math.PI / 180, lon2 = lon2_for_path * Math.PI / 180;
            const dLon = lon2 - lon1;
            const d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(dLon));
            if (Math.abs(d) < 1e-6) return [latlng1, latlng2];
            let lastLon = null;
            for (let i = 0; i <= numPoints; i++) {
                const f = i / numPoints;
                const A = Math.sin((1 - f) * d) / Math.sin(d);
                const B = Math.sin(f * d) / Math.sin(d);
                const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
                const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
                const z = A * Math.sin(lat1) + B * Math.sin(lat2);
                const lat = Math.atan2(z, Math.sqrt(x * x + y * y)) * 180 / Math.PI;
                let lon = Math.atan2(y, x) * 180 / Math.PI;
                if (lastLon !== null) {
                    if (lon - lastLon > 180) lon -= 360;
                    else if (lastLon - lon > 180) lon += 360;
                }
                points.push(L.latLng(lat, lon));
                lastLon = lon;
            }
            return points;
        }
        
        function calculateDistance(latlng1, latlng2) {
            const R_miles = 3958.8;
            const R_km = 6371;
            const toRad = (deg) => deg * Math.PI / 180;
            const dLat = toRad(latlng2.lat - latlng1.lat);
            const dLon = toRad(latlng2.lng - latlng1.lng);
            const lat1 = toRad(latlng1.lat);
            const lat2 = toRad(latlng2.lat);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); 
            const distanceMiles = R_miles * c;
            const distanceKm = R_km * c;
            const milesStr = Math.round(distanceMiles).toLocaleString('en-US');
            const kmStr = Math.round(distanceKm).toLocaleString('en-US');
            return `${milesStr} miles (${kmStr} km)`;
        }

        function updatePolylines() {
            allPolylines.clearLayers();
            const latlng1 = markerFamily1[0].getLatLng();
            const latlng2 = markerFamily2[0].getLatLng();
            const mainPoints = getGreatCirclePoints(latlng1, latlng2);
            // Changed line color to be more visible on a dark background
            const polylineOptions = { color: '#FFFFFF', weight: 3, opacity: 0.7, dashArray: '5, 10' };

            for (let i = -3; i <= 3; i++) {
                const offset = i * 360;
                const offsetPoints = mainPoints.map(p => L.latLng(p.lat, p.lng + offset));
                L.polyline(offsetPoints, polylineOptions).addTo(allPolylines);
            }
            
            const distanceDisplayElement = document.getElementById('distance-display');
            if (distanceDisplayElement) {
                distanceDisplayElement.textContent = calculateDistance(latlng1, latlng2);
            }
        }
        
        function onMarkerDrag(e) {
            const draggedMarker = e.target;
            const latlng = draggedMarker.getLatLng();
            const clampedLat = Math.max(-85, Math.min(85, latlng.lat));
            let baseLng = latlng.lng;
            while (baseLng > 180) baseLng -= 360;
            while (baseLng < -180) baseLng += 360;
            const family = markerFamily1.includes(draggedMarker) ? markerFamily1 : markerFamily2;
            family.forEach((marker, index) => {
                const offset = (index - 3) * 360;
                marker.setLatLng([clampedLat, baseLng + offset]);
            });
            updatePolylines();
        }

        function zoomToFitLine() {
            const lineBounds = L.latLngBounds(getGreatCirclePoints(markerFamily1[0].getLatLng(), markerFamily2[0].getLatLng()));
            if (lineBounds.isValid()) {
                map.flyToBounds(lineBounds, { padding: [50, 50] });
            }
        }

        function createCustomIcon(color, opacity) {
            const iconSvg = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="36" height="36" fill="${color}" stroke="white" stroke-width="1.5" style="filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); opacity: ${opacity};">
                  <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>`;
            return L.divIcon({ html: iconSvg, className: '', iconSize: [36, 36], iconAnchor: [18, 36] });
        }

        [...markerFamily1, ...markerFamily2].forEach(marker => {
            marker.on('drag', onMarkerDrag);
        });
        
        // --- Search Functionality ---
        const searchControl = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar');
                container.id = 'search-container';
                container.innerHTML = `
                    <div class="search-group">
                        <span class="search-icon" style="background-color: #3B82F6;"></span>
                        <div class="input-wrapper">
                            <input type="text" id="search-input-1" class="search-input" placeholder="Search for a place...">
                            <span class="clear-search" id="clear-search-1">&times;</span>
                        </div>
                        <button id="search-button-1" class="search-button">Search</button>
                    </div>
                    <div class="search-group">
                        <span class="search-icon" style="background-color: #EF4444;"></span>
                        <div class="input-wrapper">
                            <input type="text" id="search-input-2" class="search-input" placeholder="Search for a place...">
                            <span class="clear-search" id="clear-search-2">&times;</span>
                        </div>
                        <button id="search-button-2" class="search-button">Search</button>
                    </div>
                    <div id="distance-display"></div>`;
                L.DomEvent.disableClickPropagation(container);
                return container;
            }
        });
        
        map.addControl(new searchControl());

        async function searchLocation(markerFamily, inputElement) {
            const query = inputElement.value;
            if (!query) return;
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat), lon = parseFloat(result.lon);
                    markerFamily.forEach((marker, index) => {
                        marker.setLatLng([lat, lon + (index - 3) * 360]);
                    });
                    updatePolylines();
                    zoomToFitLine();
                    inputElement.value = result.display_name;
                } else {
                    const originalValue = inputElement.value;
                    inputElement.value = '';
                    inputElement.placeholder = 'Place not found.';
                    setTimeout(() => { 
                        inputElement.placeholder = 'Search for a place...';
                        inputElement.value = originalValue;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error during search:', error);
                inputElement.placeholder = 'Search failed.';
            }
        }

        function setupSearch(inputId, clearId, buttonId, markerFamily) {
            const inputEl = document.getElementById(inputId);
            const clearEl = document.getElementById(clearId);
            const buttonEl = document.getElementById(buttonId);
            buttonEl.addEventListener('click', () => searchLocation(markerFamily, inputEl));
            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') searchLocation(markerFamily, inputEl);
            });
            inputEl.addEventListener('input', () => {
                clearEl.style.display = inputEl.value ? 'block' : 'none';
            });
            clearEl.addEventListener('click', () => {
                inputEl.value = '';
                clearEl.style.display = 'none';
                inputEl.focus();
            });
        }

        setupSearch('search-input-1', 'clear-search-1', 'search-button-1', markerFamily1);
        setupSearch('search-input-2', 'clear-search-2', 'search-button-2', markerFamily2);

        // --- FINAL INITIALIZATION ---
        updatePolylines();
        zoomToFitLine();

    </script>
</body>
</html>
